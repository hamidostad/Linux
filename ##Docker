##Docker

docker run -d centos /bin/bash -c 'while true; do X=$[$X+1]; echo $X; sleep 1; done'

sudo docker ps >> to show all the running containers on our system
sudo docker ps -a >> to show all the containers whether they running or not

sudo docker images >> to see all images that pull in our system.

sudo docker stop <container_name>
sudo docker start <container_name>
sudo docker logs <container id or dcontainer_name>

sudo docker search php
sudo docker pull php >> to pull php image from docker hup repository
sudo docker pull ubuntu

sudo docker version

sudo docker rmi <image name> >> remove image
sudo docker rmi php
sudo docker rm <container_name or id> >> remove a container

** You canmnot reomve a running container. Stop the container before attempting removal or use -f !

** we can have images while their containers are removed via rm

** there is no images -a because the concept does not exist, images are never running or stopped, images are staging area thar are waiting to be copeid and ruunning in place.


sudo docker run -d adejonge/helloworld
sudo docker inspect <container_name> >> to find container IP ADDRESS
sudo docker inspect <container_name> | grep IPAddress

#use port mapping to make communication between containers and other hosts in network.

sudo docker run -d -p 8080 adejonge/helloworld (-p publish port)
#in this situation the website is reachable via host ipaddress on port that is mentioned on docker ps command result.
#for example: 192.168.1.204:32759
#so it is reachble from other hosts in network as well.

#to specify the port by ourself instead of generated by docker:
sudo docker run -d -p 8000:8080 adejonge/helloworld
192.168.1.204:8000
sudo docker ps

sudo docker run -d -p 9000:8080 -p 9001:8080 adejonge/helloworld
192.168.1.204:9000
192.168.1.204:9001
sudo docker ps

sudo docker run -d --net=host adejonge/helloworld >> no portforwarding no virtual ethernet
#in this situation there would be no IP address assigned for container and the website is reachable directly via host ip address and port 8080.
192.168.1.204:8080

##Shared and Persistent DATA
sudo docker run -d nginx
sudo docker ps
sudo docker inspect <docker random name> | grep IPAddress
172.17.0.24

on local host:
mkdir web
cd web

sudo docker run -d -v /home/kavian/web:/usr/share/nginx/html
sudo docker ps
sudo docker inspect <docker random name> | grep IPAddress
172.17.0.25

## to set the name for container
sudo docker run -d --name myname nginx
sudo docker inspect myname | grep IPAddress

## to go to the container:
sudo docker exec -i -t myname bash (i for interactive t for terminal bash can be any command)

## to create an image from our container
sudo docker commit <container name> new_image_name
sudo docker images

## remove the old container which is running (-f for force) and create a new one from new image:
sudo docker rm -f myname
sudo docker run -d new_image_name 
sudo docker ps


## create an image
**create a directory, put our script in that folder, create a new file named Dockerfile in that directory and configure it as below. next, create an image from those files, then create a new container from the new created image.

local host:
mkdir my_counter
ls
counter.sh

vi Dockerfile

FROM ubuntu

MAINTAINER kavian karimzadeh <kavian.karimzadeh@hotmail.com>

COPY counter.sh /usr/local/bin/counter.sh

RUN chmod +x /usr/local/bin/counter.sh

CMD ["/usr/local/bin/counter.sh"]


sudo docker build -t my_counter .
sudo docker images

#create a new container from new image:
sudo docker run -d my_counter
sudo docker ps
sudo docker logs <new_container_name>


## create a container to store data for other containers:
sudo docker create --name my_data -v /usr/share/nginx/html ubuntu
sudo docker run -d --volume-from my_data nginx
sudo docker ps
sudo docker inspect <container-name> | grep IPAddress


##GUI Tools for Docker
sudo docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock dockerui/dockerui
sudo docker ps
http://127.0.0.1:9000

_______________________________

##Docker Installation and Configuration

cd /etc/yum.repos.d
vim docker.repo

[dockerrepo]
name=Docker Repository
baseurl=https://yum.dockerproject.org/repo/main/centos/7/
enabled=1
gpgcheck=1
gpgkey=https://yum.dockerproject.org/gpg


yum update

yum install -y docker-engine

systemctl enable docker
systemctl start docker

docker --version

docker images

usermod -a -G docker user
cat /etc/group | grep docker


##Docker Hub
hub.docker.com

##Base Image
#if we do not have an image we can't have container.
#so we need to pull some images first.

docker search centos
docker search apache
docker search httpd

docker pull hello-world
docker pull docker/whalesay
docker pull centos
docker pull centos:centos6  <centos6 is a tag, if we don't specify the tag, it is going to pull the latest centos version>
docker pull nginx:latest

docker images
docker inspect nginx

docker run docker/whalesay cowsay salam

#if we want to run a container, we use docker run command.

docker ps
docker ps -a

docker run -it centos:latest /bin/bash <i for interactive t for terminal>
docker run -d nginx:latest <d for deamon which means run the container in the background>

## the difference between -i and -d is that -i means interactive which run the container in the foreground and by existing the container it will stop the container but when we use -d for running docker, it will run the container in the background.

docker stop <container_name>
docker run -d --name=MyWeb1 nginx:latest
docker run -d --name=MyWeb2 nginx:latest
docker run -d --name=MyWeb3 nginx:latest
docker ps
docker inspect MyWeb1 | grep IPAddress
docker stop MyWeb2

docker exec -it LifeCycle1 /bin/bash

docker rmi centos:centos6

docker ps -a -q >> all stopped container's id
docker rm `docker ps -a -q`

docker run -d --name=WebServer1 -P nginx:latest
<-P means any port that is exposed to my container I want to make it availabe through the host OS on a random port between 32768 and 65000.>
http://localhost:<random port>

docker port WebServer1 $CONTAINERPORT

docker run -d -p 8080:80 nginx:latest
<to map the container ip to a specific port on host>
http://localhost:8080

docker run -d -p 8080:80 --name=WebServer3 -v /mnt/data nginx:latest

docker run -d -p 8080:80 --name=WebServer4 -v /home/user/www:/usr/share/nginx/html nginx:latest

##Dockerfile
#sample1
vim Dockerfile

FROM debian:stable
MAINTAINER latest123 <latest123@linuxacademy.com>

RUN apt-get update
RUN apt-get upgrade
RUN apt-get install telnet


docker build -t latest123/myapache .

#sample2
vim Dockerfile

FROM debian:stable
MAINTAINER latest123 <latest123@linuxacademy.com>

RUN apt-get update && apt-get upgrade -y && apt-get install -y telnet apache2 elinks openssh-server

ENV MYVALUE my-value

docker build -t latest123/myapache .

docker run -it latest123/myapache:latest /bin/bash
echo $MYVALUE

____________________________________________________________

Installation from repository for Ubuntu:
1.
apt-get update

2.
apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common

3.
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -

4.
apt-key fingerprint 0EBFCD88

5.
add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"

6.
apt-get update

7.
apt-get install docker-ce docker-ce-cli containerd.io

8.
docker
docker run hello-world
docker run -it ubuntu bash
cat /etc/*release*

https://docs.docker.com/

##Docker Commands
docker run ubuntu >> start a container (if the image is not existed locally, it will download it first)
docker pull ubuntu >> to only pull the image to usr that later
docker ps >> list all started containers
docker ps -a >> list all containers in all states
docker stop <container_id> or <container_name>
docker rm container_name
docker images
docker rmi <image_name> >> delete all dependant containers to remove images
docker exec container_name cat /etc/hosts >> to run a command on a running container

docker run ubuntu
docker run ubuntu:17.04
#default tag is the latest version
docker run repository_name/app_name >> attach mode
docker run -d repository_name/app_name >> detach mode
docker attach container_name

docker run -p 80:5000 repository/simple-webapp
docker run -p 8000:5000 repository/simple-webapp
docker run -p 8001:5000 repository/simple-webapp
docker run -p 3306:3306 mysql

docker run -v /opt/datadir:/var/lib/mysql mysql </opt/datadir is local direcory on our server>


##Docker Swarm cluster
to provide high availability for our containers
docker swarm init --advertise-addr 192.168.1.12 >> master
docker swarm join --token <token> >> node workers
  
##Docker default networks
#Bridge
docker run ubuntu
#none
docker run ubuntu --network=none >> isolated container
#host
docker run ubuntu --network=host

##docker by default has one private internal network (172.17.X.X)
but we can add other internal network as well:
docker network create --driver bridge --subnet 182.18.0.0/16 custom-isolated-network

docker network ls

__________________________________________________________

docker info
docker info | more
docker tag container_name
docker node ls >> on master node (docker manager)
docker info | grep 'Logging Driver'

_________________________________________________________

#interactive shell
docker run -it ubuntu /bin/bash

#disconnect without existing with (detach)
ctrl-p + ctrl-q

#
docker search tutorial
docker run learn/tutorial echo "hello world"
________________________________________________________

docker run -it --name container1 node /bin/bash
docker search database

#start a mysql server instance:
docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pass -d mysql:tag

docker network ls
# by default docker has three networks (bridge, host, none)
docker network create mynetwork
docker run -it --network=mynetwork ubuntu /bin/bash

#viewing local files in a container:
docker run -it --name local-files -v $(pwd):/data ubuntu /bin/bash


#networking a database to a web server: (a simple project)
docker network create hello-world-node
docker run --name mongo --network=hello-world-node -d mongo
docker ps
docker run -it --name node -p 3000:3000 --network=hello-world-node node /bin/bash
mkdir data
cd data
git clone https://github.com/BrooksPatton/hello_world_node.git
npm i
cd hello-world-node/
npm install
export DATABASE_URL=mongo
npm start
open a browser: localhost:3000

## create a Dockerfile that stores an environment variable
vim Dockerfile

FROM node:latest
RUN useradd -mU web
USER web
WORKDIR /home/web
RUN git clone https://github.com/BrooksPatton/hello_world_node.git
WORKDIR /home/web/hello_world_node
RUN npm install
EXPOSE 3000
ENV DATABASE_URL=mongo
CMD ["npm", "start"]

docker build -t kavian/hello_world_node .
docker images
docker ps
docker inspect mongo

docker run -d --name node -p 3000:3000 --network=hello-world-node kavian/hello_world_node
docker ps

open a browser: localhost:3000

##start the container with a volume
docker run -d --name devtest --mount source=myvol2,target=/app nginx:latest
example:
docker run -d --network=hello-world-node --name mongo --mount source=hello-world-node,target=/data/db mongo

##Docker Compose
# Compose can be used to automate container creation

vim Dockerfile

FROM node:latest
RUN useradd -mU web
USER web
WORKDIR /home/web
RUN git clone https://github.com/BrooksPatton/hello_world_node.git
WORKDIR /home/web/hello_world_node
RUN npm install
EXPOSE 3000
ENV DATABASE_URL=mongo
CMD ["npm", "start"]

#in the same directory:
vim docker-compose.yml
version: "3"
services:
	node:
		build: .
		ports:
			- "3000:3000"
		networks:
			web:
		depends_on:
			- mongo
	mongo:
		image: mongo:latest
		networks:
			web:
		volumes:
			- hello-world:/ata/db
networks:
	web:
volumes:
	hello-world:

docker-compose build
docker-compose up
docker-compose start


___________________________________________
docker ps --format $FORMAT
docker ps -l >> showing the last stopped container
docker commit container_id
docker tag <sha_number> my-image
docker images
docker run -ti my-image bash
docker kill <container_name>

##Memory limits
docker run --momory maximum-allowed-memory <image-name> command

##CPU limits
docker run --cpu-shares >> relative to other containers
docker run --cpu-quota >> to limit it in general
 
**Don't let your containers fetch dependencies when they start
**Don't leave important things in unnamed stopped containers

docker run -it -p <outside port>:<inside of container port> ubuntu bash

#Link containers:
docker run -it --rm --name server ubuntu bash
docker run -it --rm --link server --name client ubuntu bash

#Dockerfile
docker build -t <name> .

#dockerfiles look like shell scripts but are not shell scripts
#processes you start on one line will not be running on the next line
#environment variable you set will be set on the next line

FROM debian:sid
RUN apt-get -y update
RUN apt-get install nano
CMD ["/bin/nano", "/tmp/notes"]

##Adding a file through Docker Build
FROM example/nanoer
ADD notes.txt /notes.txt
CMD "nano" "/notex.txt"


#
docker run -e "HELLO=OREILLY" ubuntu /bin/bash -c export 

docker run -d -P --name redis redis
docker inspect	redis >> to find the IP address
docker run -d -e "REDIS_PORT_6379_TCP_ADDR=172.17.0.2" --name web -p 4567:4567 rickfast/oreilly-simple-web-app

docker stop --time 10 container_name

docker inspect --format ='{{.NetworkSettings.IPAddress}}' redis

##Builiding Images:

docker search alpine

docker run -it alpine /bin/bash
apk update
apk add nodejs
node --version
mkdir average
cd average
vi average.js
#!/bin/bash
var sum = 0;
var count = 0;
process.argv.forEach(function (val, index, array) {
	if(index > 1) {
	 sum += parseInt(val);
	 count ++;
	}
});
console.log(sum / count);


chmod +x average.js
./average.js 3 4 5

hostname
<copy the container_name>
exit 
docker commit -m "installed node and wrote average application" <paste the container_name>


##using Dockerfile
FROM alpine
MAINTAINER rickfast <rick.t.dast@gmail.com>
RUN apk update && apk add nodejs
RUN mkdir average
ADD average.js average/
WORKDIR average
ENTRYPOINT ["node","average.js"]

docker build -t rickfast/average .

##docker network
docker network ls

none:
docker run -d -P --net none --name no-network-app rickfast/hello-oreilly-http
docker exec -it no-network-app /bin/bash

docker run -d -P --net host --name host-network-app rickfast/hello-oreilly-http
docker exec -it host-network-app /bin/bash

docker network create --driver bridge my-network
docker network ls

docker run -d -P --net my-network --name hello rickfast/hello-oreilly-http
docker inspect hello

##docker volume
docker run -d -p 5984:5984 -v $(pwd)/data:/usr/local/var/lib/couchdb --name couchdb klaemo/couchdb

curl -X PUT http://192.168.99.100:5984

##data volume container:
docker create -v /usr/local/var/lib/couchdb --name db-data debian:jessie /bin/true

docker run -d -p 5984:5984 -v /usr/local/var/lib/couchdb --name db1 --volumes-from db-data klaemo/couchdb

______________________________________________________________________________________________________________

cd /var/run

docker commit -m "Already installed SSH and created test user" -a "kavian" <container_name or id> kavian/ubuntusshd:v1
(a for maintainer)

docker images
docker run -it kavian/ubuntusshd:v1 /bin/bash


docker exec container_name /bin/cat /etc/profile


##Dockerfile
 
vim Dockerfile
FROM ubuntu:xenial
MAINTAINER kavian <kavian@kavian.com>
RUN apt-get update
RUN apt-get install -y telnet openssh-server


docker build -t="kavian/ubusshdonly:v2" .


mkdir Builds
cd Builds/
mkdir RunAsUser
cd RunAsUser/
docker images
vim Dockerfile

  1 Dockerfile based on the latest Centos 7 image - non-privileged user entry
  2 FROM centos:latest
  3 MAINTAINER ballmerkurt@gmail.com
  4 
  5 RUN useradd -ms /bin/bash user
  6 USER user

docker build -t centos7/nonroot:v1 .
docker images
docker run -it centos7/nonroot:v1 /bin/bash >> connect to container with user user!
docker ps
docker exec -u 0 -it elastic_goodall /bin/bash >> connect to container with root user! 

****

RUN is an image build step, the state of the container after a RUN command will be committed to the container image. A Dockerfile can have many RUN steps that layer on top of one another to build the image.

CMD is the command the container executes by default when you launch the built image. A Dockerfile can only have one CMD. The CMD can be overridden when starting a container with docker run $image $other_command.

ENTRYPOINT is also closely related to CMD and can modify the way a container starts an image.

****

##RUN order Execution

  1 #Dockerfile based on the latest Centos 7 image - non-privileged user entry
  2 FROM centos:latest
  3 MAINTAINER ballmerkurt@gmail.com
  4 
  5 RUN useradd -ms /bin/bash user
  6 RUN echo "EXPORT 192.168.0.0/24" >> /etc/exports.list
  7 
  8 USER user

since modifying /etc directory need root privilege, so we should put the RUN echo before chnaging to standard user.

_______________________

  1 #Dockerfile based on the latest Centos 7 image - non-privileged user entry
  2 FROM centos:latest
  3 MAINTAINER ballmerkurt@gmail.com
  4 
  5 RUN useradd -ms /bin/bash user
  6 RUN echo "EXPORT 192.168.0.0/24" >> /etc/exports.list
  7 
  8 RUN yum update -y
  9 RUN yum install -y net-tools wget
 10 
 11 RUN cd ~ && wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "https://download.oracle.com/otn-pub/java/jdk/8u231-b11/5b13a193868b4bf28bcb45c792fce896/jre-8u231-linux-x64.rpm"
 12 
 13 RUN yum localinstall -y ~/jre-8u231-linux-x64.rpm
 14 
 15 USER user
 16 
 17 RUN cd ~ && echo "export JAVA_HOME=/usr/java/jdk1.8.0/jre" >> /home/user/.bashrc

docker build -t centos/java8:v1 .
docker run -it centos/java8:v1 /bin/bash
env
______________________

system wide environment

  1 #Dockerfile based on the latest Centos 7 image - non-privileged user entry
  2 FROM centos:latest
  3 MAINTAINER ballmerkurt@gmail.com
  4 
  5 RUN useradd -ms /bin/bash user
  6 RUN echo "EXPORT 192.168.0.0/24" >> /etc/exports.list
  7 
  8 RUN yum update -y
  9 RUN yum install -y net-tools wget
 10 
 11 RUN cd ~ && wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2    F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "https://download.oracl    e.com/otn-pub/java/jdk/8u231-b11/5b13a193868b4bf28bcb45c792fce896/jre-8u231-linux-x64.rp    m"
 12 
 13 RUN yum localinstall -y ~/jre-8u231-linux-x64.rpm
 14 
 15 USER user
 16 
 17 RUN cd ~ && echo "export JAVA_HOME=/usr/java/jdk1.8.0/jre" >> /home/user/.bashrc
 18
 19 ENV JAVA_BIN /usr/java/jdk1.8.0/jre/bin

docker build -t centos/java8:v2 .
docker run -it centos/java8:v2 /bin/bash
env

______________________

CMD:

FROM centos:latest
MAINTAINER ballmerkurt@gmail.com

RUN useradd -ms /bin/bash user

CMD "echo" "This is a custom container message for our students"

USER user

docker build -t centos/echo:v1 .
docker run centos/echo:v1

__________________

ENTRYPOINT:

the command we use in front of ENTRYPOINT will do on every cotainer that is run from it in any condition but with CMD it can be overridden when starting a container with docker run $image $other_command.

CMD instruction allows you to set a default command, which will be executed only when you run container without specifying a command. If Docker container runs with a command, the default command will be ignored. If Dockerfile has more than one CMD instruction, all but last CMD instructions are ignored.

ENTRYPOINT instruction allows you to configure a container that will run as an executable. It looks similar to CMD, because it also allows you to specify a command with parameters. The difference is ENTRYPOINT command and parameters are not ignored when Docker container runs with command line parameters.

Prefer ENTRYPOINT to CMD when building executable Docker image and you need a command always to be executed. Additionally use CMD if you need to provide extra default arguments that could be overwritten from command line when docker container runs.

Choose CMD if you need to provide a default command and/or arguments that can be overwritten from command line when docker container runs.

FROM centos:latest
MAINTAINER ballmerkurt@gmail.com

RUN useradd -ms /bin/bash user

ENTRYPOINT echo "This command will display this message on EVERY container that is run from it"

USER user

docker build -t centos/entry:v1 .
docker run centos/entry:v1 

docker run centos/echo:v1 /bin/echo "Hello from the web"
docker run centos/entry:v1 /bin/bash
docker run centos/entry:v1 /bin/echo "Will you see me?"

________________________________

##EXPOSE
to automatically remapped the exposed port to my localhost <0.0.0.0> interface on the first available port in the range 32768 up to 65000.


#This image is based on  Centos 7 and will start apache service in each container
FROM centos:latest
MAINTAINER ballmer.kurt@gmail.com
RUN yum update -y
RUN yum install -y httpd net-tools
RUN echo "This is a custom index file build during the image creation" > /var/www/html/index.html
ENTRYPOINT apachectl "-DFOREGROUND"


docker build -t centos/apache:v1 .
docker run -d --name apacheweb1 centos/apache:v1
docker inspect apacheweb1 | grep IPAd
elink http://172.17.0.2
docker exec apacheweb1 /bin/cat /var/wwww/html/index.html
docker run -d --name apacheweb2 -P centos/apache:v1
docker ps
docker run -d --name apacheweb3 -p 8080:80 centos/apache:v1
elink http://localhost:8080


FROM centos:latest
MAINTAINER ballmer.kurt@gmail.com
RUN yum update -y
RUN yum install -y httpd net-tools
RUN echo "This is a custom index file build during the image creation" > /var/www/html/index.html
EXPOSE 80
ENTRYPOINT apachectl "-DFOREGROUND"

docker build -t centos/apache:v2 .
docker run -d --name apacheweb4 -P centos/apache:v2
docker ps
elink http://localhost:32768

_____________________________________

docker run -it --name myvoltest -v /mydata centos /bin/bash

/var/lib/docker/volumes/48e995f56d7205262befa70d4d59f1
f290d3881e6457a0801fcc3529f9278a2e/_data/

docker run -it --name myvoltest1 -v /root/myhostdir:/mydata centos /bin/bash

_____________________________________

docker network ls
docker network create --subnet 10.1.0.0/24 --gateway 10.1.0.1 mybridge1
docker network inspect mybridge1
docker network rm mybridge1

docker network create --subnet 10.1.0.0/16 --gateway 10.1.0.1 --ip-range=10.1.4.0/24 --driver=bridge --label=host4network bridge4

docker run -it --name nettest1 --net bridge4 centos /bin/bash
docker run -it --name nettest2 --net bridge4 --ip 10.1.4.100 centos /bin/bash

______________________________________

docker run -itd -p 127.0.0.1:8081:80 nginx:latest
docker run -itd -p 127.0.0.1:8081:80/udp nginx:latest

_______________________________________

docker rename old_container_name new_container_name
docker rename old_container_id new_container_name

_______________________________________

docker events
docker events --since '1h'
docker events --since '5m'
docker events --filter envet=attach --filter event=die --filter event=stop
docker events --since '5m' --format '{{json .}}'

_______________________________________

docker commit mycontainer centos:mine
docker save --output centos.latest.tar centos:latest
gzip centos.latest.tar
docker load --input centos.latest.tar.gz

_______________________________________

docker history <image-name>
docker history --no-trunc <image-name>
docker history --quiet --no-trunc <image-name>

_______________________________________

docker tag <image_id> mine/centos:v.1.0
docker images

_______________________________________

docker login
cd .docker
cd
docker logout

docker login --username=<login id> 
docker push image:tag
docker logout
_______________________________________

##Building a web farm:
docker pull centos:centos6
docker images
docker run -it centos:centos6 /bin/bash
yum install -y wget
wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
rpm -Uvh epel-release-6-8.noarch.rpm
yum -y update
yum install -y which sudo httpd php openssh-server
which service
whoami

vi .bashrc
#add the ervice that we want to start
/sbin/service httpd start
/sbin/service sshd start

exit

docker commit container_id centos6:baseweb
docker images

docker run -it centos6:baseweb /bin/bash

docker run -itd --name=externalweb -p 8081:80 -v /root/docker/dockerwww/:/var/www/html centos6:ser
verv1 /bin/bash
_________________________________________

##installing nginx to use it as proxy and load balancer for all request to two container.
docker run -it --name=devweb1 -p 8081:80 -v /root/docker/dockerwww/:/var/www/html centos6:serverv1 /bin/bash
docker run -it --name=devweb2 -p 8082:80 -v /root/docker/dockerwww/:/var/www/html centos6:serverv1 /bin/bash

on docker host:
yum install -y nginx
service nginx.service start

cd /etc/nginx
cd sites-available
vi default.conf

upstream containerapp {
	server 192.168.1.35:8081;
	server 192.168.1.35:8082;
}

server {
	listen *:80;

	server_name 192.168.1.35;
	index index.html index.htm index.php;

	acces_log /var/log/nginx/localweb.log;
	error_log /var/log/nginx/localerr.log;

	location / {
			proxy_pass http://containerapp;
	}
}

systemctl restart nginx

_________________________________________

FROM alpine
RUN apk add --update lighttpd
COPY etc/lighttpd/* /etc/lighttpd/
COPY var/www/html/* /var/www/html/
EXPOSE 80
CMD ["lighttpd","-D","-f","/etc/lighttpd/lighttpd.conf"]

vim etc/lighttpd/lighttpd.conf
server.document-root = "/var/www/html/"
server.port = 80
server.indexfiles = ("index.html")
mimetype.assign = (".html => "text/html")

vim var/www/html/index.html
<html>
		<body>
				<h1>Wlcome to Light HTTP Server>/h1>
</body>
</html>

docker build -t lightweb:v1 .

__________________________________________

FROM node:carbon
WORKDIR /usr/src/app
ENV foo "bar"
RUN echo $foo
RUN echo ${foo}
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 8080
CMD [ "npm", "start" ]

__________________________________________

docker tag kavian/node-web-app kavian/node-web-app:v0.0.0
__________________________________________

docker volume create web-vol
docker volume ls
docker volume rm vol-name
docker run --name cont1 --volume web-vol:/app centos

name-of-the-volume:file-or-location-in-docker:access-rights

__________________________________________

docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
__________________________________________

docker update -m 100M cont1
docker stats
__________________________________________

docker compose

version: '2'
services:
	elasticsearch:
		image: elasticsearch:2.2.1
	kibana:
		image: kibana:4.4.2
		ports:
			- "5601:5601"
		environment:
			- ELASTICSEARCH_URL=http://elasticsearch:9200
		depends_on:
			- elasticsearch
	logstash:
		image: logstash:2.2.2
		command: -e 'input { tcp { port => 5555 } } output { elasticsearch { hosts => {"elasticsearch:9200"} } }'
		ports:
			- "5555:5555"
		depends_on:
			- elasticsearch


__________________________________________

Cleaning Up Stopped Containers

docker rm -v $(docker ps -aq -f status=exited)
__________________________________________

docker run -it --rm -v "$(pwd)/challenge.php:/home/challenge.php" php:latest /bin/bash
__________________________________________

docker logs -f mycontainer
docker logs --tail 10 mycontainer
__________________________________________

docker run -d -P httpd --name myweb
docker logs -f myweb
__________________________________________
healthcheck
crul -I "http://localhost:32777"
crul -I --fail "http://localhost:32777"
crul -I --fail "http://localhost:32777" || exit 1

##httpd
FROM httpd:latest
RUN apt-get update && apt-get install -y --no-install-recommends curl && aptget clean
EXPOSE 80
HEALTHCHECK --interval=15s --retries=5 --timeout=30s --start-period=30s CMD curl -I -f "http://localhost:80" || exit 1

docker build . -t httpd-hc
docker run -d -P --name httpd-myweb httpd-hc
docker logs -f httpd-myweb
docker ps

##tomcat
FROM tomcat:latest
RUN apt-get update && apt-get install -y --no-install-recommends curl && aptget clean
HEALTHCHECK --interval=20s --retries=5 --timeout=30s --start-period=5s CMD curl -I -f "http://localhost:8080" || exit 1

docker build . -t tomcat-hc
docker run -d -P --name tomcat-myweb tomcat-hc
docker ps
docker logs -f tomcat-myweb
__________________________________________
#docker compose

docker-compose up
docker-compose up -d

docker-compose.yml

version: '3.1'

services:
	db:
		image: mysql:latest
		restart: always
		environment:
			MYSQL_ROOT_PASSWORD: password
	adminer:
		image: adminer:latest
		restart: always
		ports:
			- 8080:8080

__________________________________________
 
version: '3.1'

services:
	db:
		image: mysql:latest
		restart: always
		environment:
			MYSQL_ROOT_PASSWORD: password
		networks:
			- backend
	adminer:
		image: adminer:latest
		restart: always
		ports:
			- 8080:8080
		networks:
			- frontend
networks:
	frontend:
		driver: bridge
	backend:
		driver: bridge


#to add another container to the already created containers with docker compose:
docker network connect <network name> <container name>

docker network ls
docker network inspect <network name>

#to disconnect a container from the network
docker network disconnect <network name> <container name>
__________________________________________

#docker composer scaling
docker-compose up -d --scale nginx=3

docker ps -f health=unhealthy -q
docker restart $(docker ps -f health=unhealthy -q)


version: '3.1'

services:
	web:
		image: httpd:latest
		restart: always

docker-compose -p challenge -f docker-compose-httpd.yml -d
docker-compose -p challenge -f docker-compose-httpd.yml -d --scale web=3
docker ps

__________________________________________

version: '3.1'

services:
	nginx:
		image: nginx:latest
		restart: always
		volumes:
			- nginx_volume:/usr/share/nginx/html/vol

volumes:
	nginx_volume:
		driver: local  

docker-compose up -d

__________________________________________

version: '3.1'

services:
	db:
		image: mysql:latest
		environment:
			MYSQL_ROOT_PASSWORD: password
		volumes:
			- dbdata:/var/lib/mysql
	admin:
		image: adminer:latest
		ports:
			- 8080:8080

volumes:
	dbdata:
		driver: local

__________________________________________

version: '3.1'

services:
	nginx:
		build: .
		environment:
			TEST_ENV: tester123
		restart: always
		volumes:
			- nginx_volume:/usr/share/nginx/html/vol
	httpd:
		image: httpd:latest
		ports:
			- 81:80
			- 8081:8080

volumes:
	nginx_volume:
		driver: local
		